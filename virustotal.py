import requests
from re import match
from datetime import timedelta, datetime
from os.path import isfile, getsize

def handleAPIResponse(statuscode: int) -> bool:
    if statuscode == 204:
        raise RateLimitError(statuscode)
    elif statuscode == 400:
        raise BadRequestError(statuscode)
    elif statuscode == 403:
        raise NotProError(statuscode)
    elif statuscode == 200:
        return True
    else:
        raise UnhandledStatusCodeError(statuscode)

def isMD5(hash: str) -> bool:
    return match('^[a-f0-9]{32}$', hash) is not None

def isSHA1(hash: str) -> bool:
    return match('^[a-f0-9]{40}$', hash) is not None

def isSHA256(hash: str) -> bool:
    return match('^[a-f0-9]{64}$', hash) is not None

def toMB(bytes) -> int:
    return int(round(bytes / 1048576, 0))

class VT_Error(Exception):
    """ Base class for all VirusTotal exceptions """
    def __str__(self):
        return self.message
    def __repr__(self):
        return self.message

class NotProError(VT_Error):
    """ A call to an endpoint was made without Pro API privileges """

    def __init__(self, code=None):
        if code is None:
            self.message = "Bad Privileges, tried accessing Pro API privileges with a non-Pro API Key!"
        else:
            self.message = str(code) + ": Bad Privileges, tried accessing Pro API privileges with a non-Pro API Key!"

class InvalidInputError(VT_Error):
    """ A call to an endpoint that needed input was made with invalid input """

    def __init__(self, var, input, constraints):
        self.message = "Invalid input for (" + str(var) + ")! Received: (" + str(input) + ") Expected: (" + str(var) + " " + str(constraints) + ")"

class NoInputError(VT_Error):
    """ A call to an endpoint that needed input was made without any input """

    def __init__(self, var, input):
        self.message = "Missing input for (" + str(var) + ")! Received: (" + str(input) + ")"

class RateLimitError(VT_Error):
    """ A call to an endpoint was made, but the request rate limit has been exceeded """

    def __init__(self, code):
        self.message = str(code) + ": Request rate limit exceeded!"

class BadRequestError(VT_Error):
    """ A call to an endpoint was made, but a bad request error was returned from VirusTotal """

    def __init__(self, code):
        self.message = str(code) + ": Bad request!"

class UnhandledStatusCodeError(VT_Error):
    """ A call to an endpoint was made, but the server returned a status code that was not documented """

    def __init__(self, code):
        self.message = str(code) + ": Unhandled status code!"

class ConnectionError(VT_Error):
    """ Unable to establish a connection to VirusTotal """

    def __init__(self, url):
        self.message = "Failed to connect to " + url + "!"

class NoFileError(VT_Error):
    """ A file specified to be scanned does not exist """

    def __init__(self, filename):
        self.message = "The file (" + filename + ") does not exist!"

class LargeFileError(VT_Error):
    """ An attempt to scan a file greater than 32MB was made without using a special upload URL """

    def __init__(self, filename, size):
        self.message = "Failed to upload file (" + filename + "), file size (" + str(size) + "MB) is greater than 32MB! Please use a special upload URL."

class VirusTotal:
    """ A wrapper class containing all API calls for VirusTotal """

    def __init__(self, api, isPro=False):
        self.apikey = api
        self.isPro = isPro
        self.baseurl = 'https://www.virustotal.com/vtapi/v2'
        
        self.File = self.File(self.apikey, self.isPro, self.baseurl)
        self.URL = self.URL(self.apikey, self.isPro, self.baseurl)
        self.Domain = self.Domain(self.apikey, self.isPro, self.baseurl)
        self.IpAddress = self.IpAddress(self.apikey, self.isPro, self.baseurl)
        self.Comments = self.Comments(self.apikey, self.isPro, self.baseurl)

    def __repr__(self):
        return str(self.getEndpoints())

    def getEndpoints(self) -> dict:
        return {
            "file": self.File.getEndpoints(),
            "url": self.URL.getEndpoints(),
            "domain": self.Domain.getEndpoints(),
            "ipaddress": self.IpAddress.getEndpoints(),
            "comments": self.Comments.getEndpoints()
        }

    class File:
        """ A wrapper class containing all file-related API calls for VirusTotal """

        def __init__(self, api, isPro, baseurl):
            self.apikey = api
            self.isPro = isPro
            self.baseurl = baseurl + '/file'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/file'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/report", "method": "GET"},
                {"url": endpoints['base'] + "/scan", "method": "POST"},
                {"url": endpoints['base'] + "/scan/upload_url", "method": "GET"},
                {"url": endpoints['base'] + "/rescan", "method": "POST"},
                {"url": endpoints['base'] + "/download", "method": "GET"},
                {"url": endpoints['base'] + "/behaviour", "method": "GET"},
                {"url": endpoints['base'] + "/network-traffic", "method": "GET"},
                {"url": endpoints['base'] + "/feed", "method": "GET"},
                {"url": endpoints['base'] + "/clusters", "method": "GET"},
                {"url": endpoints['base'] + "/search", "method": "GET"}
            ]
            return endpoints

        def report(self, resource: str, allinfo: bool = False) -> dict:
            if not self.isPro:
                allinfo = False

            if resource is None:
                raise NoInputError("resource", resource)
            elif not (isMD5(resource) or isSHA1(resource) or isSHA256(resource)):
                raise InvalidInputError("resource", resource, "is MD5, SHA-1, or SHA-256 hash")
            
            # GET
            url = self.baseurl + '/report'
            params = {'apikey': self.apikey, 'resource': resource}
            
            try:
                response = requests.get(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

        def scan(self, file: str, specialurl: str = None) -> dict:
            if file is None:
                raise NoInputError("file", file)

            # validate that file is a file that exists on the server (has already been uploaded)
            if not isfile(file):
                raise NoFileError(file)
                
            # validate that file size if less than 32MB, otherwise ensure that specialurl is not None and that file is less than 200MB
            if toMB(getsize(file)) >= 32:
                raise LargeFileError(file, toMB(getsize(file)))

            # POST
            if specialurl is None:
                url = self.baseurl + '/scan'
            else:
                url = specialurl
            
            params = {'apikey': self.apikey}
            files = {'file': (file, open(file, 'rb'))}
            
            try:
                response = requests.post(url, params=params, files=files)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

        def scan_uploadurl(self) -> str:
            if self.isPro:
                # GET
                url = self.baseurl + '/scan/upload_url'
                params = {'apikey': self.apikey}

                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    if response.json().get('upload_url'):
                        return response.json()['upload_url']
            else:
                raise NotProError()

        def rescan(self, resource: str) -> dict:
            if resource is None:
                raise NoInputError("resource", resource)
            elif not (isMD5(resource) or isSHA1(resource) or isSHA256(resource)):
                raise InvalidInputError("resource", resource, "is MD5, SHA-1, or SHA-256 hash")
            
            # POST
            url = self.baseurl + '/rescan'
            params = {'apikey': self.apikey, 'resource': resource}
            
            try:
                response = requests.get(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

        def download(self, hash: str) -> bytes:
            if self.isPro:
                if hash is None:
                    raise NoInputError("hash", hash)
                elif not (isMD5(hash) or isSHA1(hash) or isSHA256(hash)):
                    raise InvalidInputError("hash", hash, "is MD5, SHA-1, or SHA-256 hash")

                # GET
                url = self.baseurl + '/download'
                params = {'apikey': self.apikey, 'hash': hash}
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.content
            else:
                raise NotProError()

        def behaviour(self, hash: str) -> dict:
            if self.isPro:
                if hash is None:
                    raise NoInputError("hash", hash)
                elif not (isMD5(hash) or isSHA1(hash) or isSHA256(hash)):
                    raise InvalidInputError("hash", hash, "is MD5, SHA-1, or SHA-256 hash")

                # GET
                url = self.baseurl + '/behaviour'
                params = {'apikey': self.apikey, 'hash': hash}
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.json()
            else:
                raise NotProError()

        def networktraffic(self, hash: str) -> dict:
            if self.isPro:
                if hash is None:
                    raise NoInputError("hash", hash)
                elif not (isMD5(hash) or isSHA1(hash) or isSHA256(hash)):
                    raise InvalidInputError("hash", hash, "is MD5, SHA-1, or SHA-256 hash")

                # GET
                url = self.baseurl + '/network-traffic'
                params = {'apikey': self.apikey, 'hash': hash}
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.json()
            else:
                raise NotProError()

        def feed(self, timestamp: str) -> str:
            if self.isPro:
                if timestamp is None:
                    raise NoInputError("timestamp", timestamp)
                
                # validate timestamp format
                try:
                    time_utc = datetime.strptime(timestamp, '%Y%m%dT%H%M')
                except ValueError:
                    try:
                        time_utc = datetime.strptime(timestamp, '%Y%m%dT%H')
                    except ValueError:
                        raise InvalidInputError("timestamp", timestamp, "in format '%Y%m%dT%H%M' or '%Y%m%dT%H'")


                # validate that timestamp is less than 24 hours ago, UTC
                if datetime.utcnow() - time_utc > timedelta(1):
                    raise InvalidInputError("timestamp", timestamp, "< 24 hours ago, UTC")

                # GET
                url = self.baseurl + '/feed'
                params = {'apikey': self.apikey, 'package': timestamp}
                
                try:
                    response = requests.get(url, params=params, stream=True, allow_redirects=True)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                # verify that package.tar.bz2 does not exist beforehand
                with open('package.tar.bz2', 'wb') as fd:
                    for chunk in response.iter_content(chunk_size=65536):
                        fd.write(chunk)

                if handleAPIResponse(response.status_code):
                    return 'package.tar.bz2'
            else:
                raise NotProError()

        def clusters(self, date: str) -> dict:
            if self.isPro:
                if date is None:
                    raise NoInputError("date", date)
                
                # validate that date is in format YYYY-MM-DD
                try:
                    datetime.strptime(date, '%Y-%m-%d')
                except ValueError:
                    raise InvalidInputError("date", date, "in format YYYY-MM-DD")

                # GET
                url = self.baseurl + '/clusters'
                params = {'apikey': self.apikey, 'date': date}
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.json()
            else:
                raise NotProError()

        def search(self, query: str, offset: str = None) -> dict:
            if self.isPro:
                if query is None:
                    raise NoInputError("query", query)

                # GET
                url = self.baseurl + '/search'
                params = {'apikey': self.apikey, 'query': query}
                if offset is not None:
                    params['offset'] = offset
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.json()
            else:
                raise NotProError()

    class URL:
        """ A wrapper class containing all url-related API calls for VirusTotal """
        
        def __init__(self, api, isPro, baseurl):
            self.apikey = api
            self.isPro = isPro
            self.baseurl = baseurl + '/url'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/url'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/report", "method": "GET"},
                {"url": endpoints['base'] + "/scan", "method": "POST"},
                {"url": endpoints['base'] + "/feed", "method": "GET"}
            ]
            return endpoints

        def report(self, resource: str, allinfo: bool = False, scan: int = 0) -> dict:
            if not self.isPro:
                allinfo = False

            if resource is None:
                raise NoInputError("resource", resource)

            # GET
            url = self.baseurl + '/report'
            params = {'apikey': self.apikey, 'resource': resource}
            if scan != 0 and scan > 0:
                params['scan'] = scan
            elif scan < 0:
                raise InvalidInputError("scan", scan, ">= 0")
            
            try:
                response = requests.get(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

        def scan(self, url: str) -> dict:
            if url is None:
                raise NoInputError("url", url)

            # POST
            url = self.baseurl + '/scan'
            params = {'apikey': self.apikey, 'url': url}
            
            try:
                response = requests.post(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

        def feed(self, timestamp: str) -> dict:
            if self.isPro:
                if timestamp is None:
                    raise NoInputError("timestamp", timestamp)

                # GET
                url = self.baseurl + '/feed'
                params = {'apikey': self.apikey, 'package': timestamp}
                
                try:
                    response = requests.get(url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)

                if handleAPIResponse(response.status_code):
                    return response.text
            else:
                raise NotProError()

    class Domain:
        """ A wrapper class containing all domain-related API calls for VirusTotal """

        def __init__(self, api, isPro, baseurl):
            self.apikey = api
            self.isPro = isPro
            self.baseurl = baseurl + '/domain'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/domain'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/report", "method": "GET"}
            ]
            return endpoints

        def report(self, domain: str) -> dict:
            if domain is None:
                raise NoInputError("domain", domain)

            # GET
            url = self.baseurl + '/report'
            params = {'apikey': self.apikey, 'domain': domain}
            
            try:
                response = requests.get(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()
    
    class IpAddress:
        """ A wrapper class containing all ip-address-related API calls for VirusTotal """

        def __init__(self, api, isPro, baseurl):
            self.apikey = api
            self.isPro = isPro
            self.baseurl = baseurl + '/ip-address'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/ip-address'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/report", "method": "GET"}
            ]
            return endpoints
        
        def report(self, ip: str) -> dict:
            if ip is None:
                raise NoInputError("ip", ip)

            # GET
            url = self.baseurl + '/report'
            params = {'apikey': self.apikey, 'ip': ip}
            
            try:
                response = requests.get(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()

    class Comments:
        """ A wrapper class containing all comment-related API calls for VirusTotal """
        
        def __init__(self, api, isPro, baseurl):
            self.apikey = api
            self.isPro = isPro
            self.baseurl = baseurl + '/comments'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/comments'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/get", "method": "GET"},
                {"url": endpoints['base'] + "/put", "method": "POST"}
            ]
            return endpoints
        
        def get(self, resource: str, before: str = None) -> str:
            if self.isPro:
                if resource is None:
                    raise NoInputError("resource", resource)
                elif not (isMD5(resource) or isSHA1(resource) or isSHA256(resource)):
                    raise InvalidInputError("resource", resource, "is MD5, SHA-1, or SHA-256 hash")

                # GET
                url = self.baseurl + '/get'
                params = {'apikey': self.apikey, 'resource': resource}
                
                if before is not None:
                    params['before'] = before
                
                try:
                    response = requests.request("GET", url, params=params)
                except requests.exceptions.ConnectionError:
                    raise ConnectionError(url)
                if handleAPIResponse(response.status_code):
                    return response.text
            else:
                raise NotProError()

        def put(self, resource: str, comment: str) -> dict:
            if resource is None:
                raise NoInputError("resource", resource)
            elif not (isMD5(resource) or isSHA1(resource) or isSHA256(resource)):
                raise InvalidInputError("resource", resource, "is MD5, SHA-1, or SHA-256 hash")

            if comment is None:
                raise NoInputError("comment", comment)

            # POST
            url = self.baseurl + '/put'
            params = {'apikey': self.apikey, 'resource': resource, 'comment': comment}
            
            try:
                response = requests.post(url, params=params)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(url)

            if handleAPIResponse(response.status_code):
                return response.json()
    