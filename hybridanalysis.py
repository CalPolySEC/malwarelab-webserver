import requests
from re import match
from datetime import timedelta, datetime
from os.path import isfile, getsize
from json import loads
from collections import OrderedDict

def handleAPIResponse(statuscode: int) -> bool:
    if statuscode == 204:
        raise RateLimitError(statuscode)
    elif statuscode == 400:
        raise BadRequestError(statuscode)
    elif statuscode == 403:
        raise BadLevelError(statuscode)
    elif statuscode == 200 or statuscode == 201:
        return True
    else:
        raise UnhandledStatusCodeError(statuscode)

def isMD5(hash: str) -> bool:
    return match('^[a-f0-9]{32}$', hash) is not None

def isSHA1(hash: str) -> bool:
    return match('^[a-f0-9]{40}$', hash) is not None

def isSHA256(hash: str) -> bool:
    return match('^[a-f0-9]{64}$', hash) is not None

def toMB(bytes) -> int:
    return int(round(bytes / 1048576, 0))

class HA_Error(Exception):
    """ Base class for all Hybrid Analysis exceptions """
    def __str__(self):
        return self.message
    def __repr__(self):
        return self.message

class BadLevelError(HA_Error):
    """ A call to an endpoint was made without Pro API privileges """

    def __init__(self, code=None):
        if code is None:
            self.message = "Bad Privileges, tried accessing Pro API privileges with a non-Pro API Key!"
        else:
            self.message = str(code) + ": Bad Privileges, tried accessing Pro API privileges with a non-Pro API Key!"

class InvalidInputError(HA_Error):
    """ A call to an endpoint that needed input was made with invalid input """

    def __init__(self, var, input, constraints):
        self.message = "Invalid input for (" + str(var) + ")! Received: (" + str(input) + ") Expected: (" + str(var) + " " + str(constraints) + ")"

class NoInputError(HA_Error):
    """ A call to an endpoint that needed input was made without any input """

    def __init__(self, var, input):
        self.message = "Missing input for (" + str(var) + ")! Received: (" + str(input) + ")"

class RateLimitError(HA_Error):
    """ A call to an endpoint was made, but the request rate limit has been exceeded """

    def __init__(self, code):
        self.message = str(code) + ": Request rate limit exceeded!"

class BadRequestError(HA_Error):
    """ A call to an endpoint was made, but a bad request error was returned from HybridAnalysis """

    def __init__(self, code):
        self.message = str(code) + ": Bad request!"

class UnhandledStatusCodeError(HA_Error):
    """ A call to an endpoint was made, but HybridAnalysis returned a status code that was not documented """

    def __init__(self, code):
        self.message = str(code) + ": Unhandled status code!"

class ConnectionError(HA_Error):
    """ Unable to establish a connection to VirusTotal """

    def __init__(self, url):
        self.message = "Failed to connect to " + url + "!"

class NoFileError(HA_Error):
    """ A file specified to be scanned does not exist """

    def __init__(self, filename):
        self.message = "The file (" + filename + ") does not exist!"

class LargeFileError(HA_Error):
    """ An attempt to scan a file greater than 32MB was made without using a special upload URL """

    def __init__(self, filename, size):
        self.message = "Failed to upload file (" + filename + "), file size (" + str(size) + "MB) is greater than 32MB! Please use a special upload URL."

class HybridAnalysis:
    """ A wrapper class containing all API calls for HybridAnalysis """

    def __init__(self, api, secret, level='default'):
        self.apikey = api
        self.secret = secret
        self.level = level
        self.baseurl = 'https://www.hybrid-analysis.com/api/v2'
        self.ua = 'Falcon Sandbox'
        
        self.Search = self.Search(self.apikey, self.level, self.baseurl, self.ua)
        self.QuickScan = self.QuickScan(self.apikey, self.level, self.baseurl, self.ua)
        self.FileCollection = self.FileCollection(self.apikey, self.level, self.baseurl, self.ua)
        self.Overview = self.Overview(self.apikey, self.level, self.baseurl, self.ua)
        self.SandboxSubmission = self.SandboxSubmission(self.apikey, self.level, self.baseurl, self.ua)
        self.SandboxReport = self.SandboxReport(self.apikey, self.level, self.baseurl, self.ua)
        self.System = self.System(self.apikey, self.level, self.baseurl, self.ua)
        self.Key = self.Key(self.apikey, self.level, self.baseurl, self.ua)
        self.Feed = self.Feed(self.apikey, self.level, self.baseurl, self.ua)
        self.AbuseReports = self.AbuseReports(self.apikey, self.level, self.baseurl, self.ua)

    def __repr__(self):
        return str(self.getEndpoints())

    def getEndpoints(self) -> dict:
        return {
            "search": self.Search.getEndpoints(),
            "quick-scan": self.QuickScan.getEndpoints(),
            "file-collection": self.FileCollection.getEndpoints(),
            "overview": self.Overview.getEndpoints(),
            "submit": self.SandboxSubmission.getEndpoints(),
            "report": self.SandboxReport.getEndpoints(),
            "system": self.System.getEndpoints(),
            "key": self.Key.getEndpoints(),
            "feed": self.Feed.getEndpoints(),
            "abuse-reports": self.AbuseReports.getEndpoints()
        }

    class Search:
        """ A wrapper class containing all search-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/search'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/search'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/hash", "method": "POST"},
                {"url": endpoints['base'] + "/hashes", "method": "POST"},
                {"url": endpoints['base'] + "/terms", "method": "POST"}
            ]
            return endpoints
        
        def hash(self, hash: str):
            # POST
            request_url = self.baseurl + '/hash'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            if isMD5(hash) or isSHA1(hash) or isSHA256(hash):
                data = {'hash': hash}
            else:
                raise Exception('Not a valid hash!')

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def hashes(self, hashes: list):
            # POST
            request_url = self.baseurl + '/hash'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            allvalid = True
            for hash in hashes:
                if isMD5(hash) or isSHA1(hash) or isSHA256(hash):
                    continue
                else:
                    allvalid = False

            if allvalid is True:
                data = {'hashes': str(hashes).replace('\'', '', -1)}
            else:
                raise Exception('Not a valid hash!')

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                print(response.headers)
                return loads(response.text)

        def terms(self, filename: str = None, filetype: str = None, filetype_desc: str = None, env_id: str = None, country: str = None, verdict: int = None, av_detect: str = None, vx_family: str = None, tag: str = None, port: int = None, host: str = None, domain: str = None, url: str = None, similar_to: str = None, context: str = None, imp_hash: str = None, ssdeep: str = None, authentihash: str = None) -> str:
            if self.level:
                # POST
                request_url = self.baseurl + '/terms'
                headers = {
                    'api-key': self.apikey,
                    'user-agent': self.ua,
                    'accept': 'application/json'
                }
                
                data = {}

                valid = False
                if filename is not None and type(filename) is str:
                    valid = True
                    data['filename'] = filename
                if filetype is not None and type(filetype) is str:
                    valid = True
                    data['filetype'] = filetype
                if filetype_desc is not None and type(filetype_desc) is str:
                    valid = True
                    data['filetype_desc'] = filetype_desc
                if env_id is not None and type(env_id) is str:
                    valid = True
                    data['env_id'] = env_id
                if country is not None and type(country) is str:
                    valid = True
                    data['country'] = country
                if verdict is not None and type(verdict) is int:
                    valid = True
                    data['verdict'] = verdict
                if av_detect is not None and type(av_detect) is str:
                    valid = True
                    data['av_detect'] = av_detect
                if vx_family is not None and type(vx_family) is str:
                    valid = True
                    data['vx_family'] = vx_family
                if tag is not None and type(tag) is str:
                    valid = True
                    data['tag'] = tag
                if port is not None and type(port) is int:
                    valid = True
                    data['port'] = port
                if host is not None and type(host) is str:
                    valid = True
                    data['host'] = host
                if domain is not None and type(domain) is str:
                    data['domain'] = domain
                if url is not None and type(url) is str:
                    valid = True
                    data['url'] = url
                if similar_to is not None and type(similar_to) is str:
                    valid = True
                    data['similar_to'] = similar_to
                if context is not None and type(context) is str:
                    valid = True
                    data['context'] = context
                if imp_hash is not None and type(imp_hash) is str:
                    valid = True
                    data['imp_hash'] = imp_hash
                if ssdeep is not None and type(ssdeep) is str:
                    valid = True
                    data['ssdeep'] = ssdeep
                if authentihash is not None and type(authentihash) is str:
                    valid = True
                    data['authentihash'] = authentihash

                if valid:
                    try:
                        response = requests.post(request_url, headers=headers, data=data)
                    except requests.exceptions.ConnectionError:
                        raise ConnectionError(request_url)

                    if handleAPIResponse(response.status_code):
                        return loads(response.text)
                else:
                    raise Exception('Invalid or missing search terms! Expected one of: {}'.format([
                        'filename',
                        'filetype',
                        'filetype_desc',
                        'env_id',
                        'country',
                        'verdict',
                        'av_detect',
                        'vx_family',
                        'tag',
                        'port',
                        'host',
                        'domain',
                        'url',
                        'similar_to',
                        'context',
                        'imp_hash',
                        'ssdeep',
                        'authentihash'
                    ]))
            else:
                raise BadLevelError()

    class QuickScan:
        """ A wrapper class containing all Quick Scan-related API calls for HybridAnalysis """
        
        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/quick-scan'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/quick-scan'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/state", "method": "GET"},
                {"url": endpoints['base'] + "/file", "method": "POST"},
                {"url": endpoints['base'] + "/url-to-file", "method": "POST"},
                {"url": endpoints['base'] + "/url-for-analysis", "method": "POST"},
                {"url": endpoints['base'] + "/{id}", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/convert-to-full", "method": "POST"}
            ]
            return endpoints
        
        def state(self) -> str:
            # GET
            request_url = self.baseurl + '/state'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }
                
            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def file(self, scan_type: str, file: str, no_share_third_party: bool = True, allow_community_access: bool = True, comment: str = None, submit_name: str = None) -> str:
            # POST
            request_url = self.baseurl + '/file'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if scan_type is not None and type(scan_type) is str:
                data['scan_type'] = scan_type
            if file is not None and type(file) is str:
                data['file'] = file
            
            if scan_type is None or file is None:
                raise Exception('Missing scan_type or file!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def url_to_file(self, scan_type: str, url: str, no_share_third_party: bool = True, allow_community_access: bool = True, comment: str = None, submit_name: str = None) -> str:
            # POST
            request_url = self.baseurl + '/url-to-file'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if scan_type is not None and type(scan_type) is str:
                data['scan_type'] = scan_type
            if url is not None and type(url) is str:
                data['url'] = url
            
            if scan_type is None or url is None:
                raise Exception('Missing scan_type or url!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def url_for_analysis(self, scan_type: str, url: str, no_share_third_party: bool = True, allow_community_access: bool = True, comment: str = None, submit_name: str = None) -> str:
            # POST
            request_url = self.baseurl + '/url-for-analysis'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if scan_type is not None and type(scan_type) is str:
                data['scan_type'] = scan_type
            if url is not None and type(url) is str:
                data['url'] = url
            
            if scan_type is None or url is None:
                raise Exception('Missing scan_type or url!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id(self, id: str):
            # GET
            request_url = self.baseurl + '/{}'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def convert_to_full(self, id: str, environment_id: str, no_share_third_party: bool = True, allow_community_access: bool = True, no_hash_lookup: bool = False, action_script: str = None, hybrid_analysis: bool = True, experimental_anti_evasion: bool = False, script_logging: bool = False, input_sample_tampering: bool = False, tor_enabled_analysis: bool = False, offline_analysis: bool = False, email: str = None, properties: str = None, comment: str = None, custom_date_time: str = None, custom_cmd_line: str = None, custom_run_time: int = None, client: str = None, submit_name: str = None, priority: int = 0, document_password: str = None, environment_variable: str = None) -> str:
            # POST
            request_url = self.baseurl + '/{}/convert-to-full'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}
            if environment_id is not None and type(environment_id) is str:
                data['environment_id'] = environment_id
            
            if environment_id is None:
                raise Exception('Missing environment_id!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if type(no_hash_lookup) is bool:
                data['no_hash_lookup'] = no_hash_lookup
            if action_script is not None and type(action_script) is str:
                data['action_script'] = action_script
            if type(hybrid_analysis) is bool:
                data['hybrid_analysis'] = hybrid_analysis
            if type(experimental_anti_evasion) is bool:
                data['experimental_anti_evasion'] = experimental_anti_evasion
            if type(script_logging) is bool:
                data['script_logging'] = script_logging
            if type(input_sample_tampering) is bool:
                data['input_sample_tampering'] = input_sample_tampering
            if type(tor_enabled_analysis) is bool:
                data['tor_enabled_analysis'] = tor_enabled_analysis
            if type(offline_analysis) is bool:
                data['offline_analysis'] = offline_analysis
            if email is not None and type(email) is str:
                data['email'] = email
            if properties is not None and type(properties) is str:
                data['properties'] = properties
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if custom_date_time is not None and type(custom_date_time) is str:
                # validate time format
                data['custom_date_time'] = custom_date_time
            if custom_cmd_line is not None and type(custom_cmd_line) is str:
                data['custom_cmd_line'] = custom_cmd_line
            if custom_run_time is not None and type(custom_run_time) is int:
                data['custom_run_time'] = custom_run_time
            if client is not None and type(client) is str:
                data['client'] = client
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name
            if priority is not None and type(priority) is int and priority in range(0, 100+1):
                data['priority'] = priority
            if document_password is not None and type(document_password) is str:
                data['document_password'] = document_password
            if environment_variable is not None and type(environment_variable) is str:
                data['environment_variable'] = environment_variable

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class FileCollection:
        """ A wrapper class containing all File Collection-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/file-collection'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/file-collection'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/create", "method": "POST"},
                {"url": endpoints['base'] + "/search", "method": "POST"},
                {"url": endpoints['base'] + "/{id}", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/files/add", "method": "POST"},
                {"url": endpoints['base'] + "/{id}/files/download", "method": "POST"},
                {"url": endpoints['base'] + "/{id}/files/download", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/files/{hash}", "method": "DELETE"},
                {"url": endpoints['base'] + "/{id}", "method": "DELETE"}
            ]
            return endpoints

        def create(self, collection_name: str = None, comment: str = None, no_share_third_party: bool = True, allow_community_access: bool = True):
            # POST
            request_url = self.baseurl + '/create'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}
            if collection_name is not None and type(collection_name) is str:
                data['collection_name'] = collection_name
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def search(self, collection_name: str, tag: str):
            # POST
            request_url = self.baseurl + '/search'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}
            if collection_name is not None and type(collection_name) is str:
                data['collection_name'] = collection_name
            if tag is not None and type(tag) is str:
                data['tag'] = tag
            
            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id(self, id: str):
            # GET
            request_url = self.baseurl + '/{}'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_files_add(self, id: str, file: str):
            raise Exception('not implemented!')
        #     # GET
        #     request_url = self.baseurl + '/{}'.format(id)
        #     headers = {
        #         'api-key': self.apikey,
        #         'user-agent': self.ua,
        #         'accept': 'application/json'
        #     }

        #     try:
        #         response = requests.get(request_url, headers=headers)
        #     except requests.exceptions.ConnectionError:
        #         raise ConnectionError(request_url)

        #     if handleAPIResponse(response.status_code):
        #         return loads(response.text)

        def id_files_download_post(self, id: str, hashes: list):
            # POST
            request_url = self.baseurl + '/{}'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {
                'hashes': hashes
            }

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                # FIX STREAM CONTENT TYPE
                raise Exception('fix stream content type!')
                return loads(response.text)

        def id_files_download_get(self, id: str):
            # GET
            request_url = self.baseurl + '/{}'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                # FIX STREAM CONTENT TYPE
                raise Exception('fix stream content type!')
                return loads(response.text)

        def id_files_download_delete(self, id: str, hash: str):
            # DELETE
            request_url = self.baseurl + '/{}/files/{}'.format(id, hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.delete(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return {'message': 'success'}

        def delete(self, id: str):
            # DELETE
            request_url = self.baseurl + '/{}'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.delete(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return {'message': 'success'}

    class Overview:
        """ A wrapper class containing all overview-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/overview'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/overview'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/{sha256}", "method": "GET"},
                {"url": endpoints['base'] + "/{sha256}/refresh", "method": "GET"},
                {"url": endpoints['base'] + "/{sha256}/summary", "method": "GET"},
                {"url": endpoints['base'] + "/{sha256}/sample", "method": "GET"}
            ]
            return endpoints

        def hash(self, hash):
            # GET
            request_url = self.baseurl + '/{}'.format(hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)
        
        def hash_refresh(self, hash):
            # GET
            request_url = self.baseurl + '/{}/refresh'.format(hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def hash_summary(self, hash):
            # GET
            request_url = self.baseurl + '/{}/summary'.format(hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def hash_sample(self, hash):
            # GET
            request_url = self.baseurl + '/{}/sample'.format(hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/gzip'
            }

            print(request_url)
            print(headers)
            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            # print(response.text)
            if handleAPIResponse(response.status_code):
                summary = self.hash(hash)
                filename = summary.get('last_file_name')
                return {'filename': filename, 'file': response.content}

    class SandboxSubmission:
        """ A wrapper class containing all Sandbox Submission-related API calls for HybridAnalysis """
        
        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/submit'

        def __repr__(self):
            return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/submit'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/file", "method": "POST"},
                {"url": endpoints['base'] + "/url-to-file", "method": "POST"},
                {"url": endpoints['base'] + "/url-for-analysis", "method": "POST"},
                {"url": endpoints['base'] + "/hash-for-url", "method": "GET"},
                {"url": endpoints['base'] + "/dropped-file", "method": "POST"}
            ]
            return endpoints
        
        def file(self, file: str, environment_id: str, no_share_third_party: bool = True, allow_community_access: bool = True, no_hash_lookup: bool = False, action_script: str = None, hybrid_analysis: bool = True, experimental_anti_evasion: bool = False, script_logging: bool = False, input_sample_tampering: bool = False, tor_enabled_analysis: bool = False, offline_analysis: bool = False, email: str = None, properties: str = None, comment: str = None, custom_date_time: str = None, custom_cmd_line: str = None, custom_run_time: int = None, client: str = None, submit_name: str = None, priority: int = 0, document_password: str = None, environment_variable: str = None) -> str:
            # POST
            request_url = self.baseurl + '/file'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if file is not None and type(file) is str:
                # validate for correct datatype
                data['file'] = file
            if environment_id is not None and type(environment_id) is int:
                data['environment_id'] = environment_id
            
            if file is None or environment_id is None:
                raise Exception('Missing file or environment_id!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if type(no_hash_lookup) is bool:
                data['no_hash_lookup'] = no_hash_lookup
            if action_script is not None and type(action_script) is str:
                data['action_script'] = action_script
            if type(hybrid_analysis) is bool:
                data['hybrid_analysis'] = hybrid_analysis
            if type(experimental_anti_evasion) is bool:
                data['experimental_anti_evasion'] = experimental_anti_evasion
            if type(script_logging) is bool:
                data['script_logging'] = script_logging
            if type(input_sample_tampering) is bool:
                data['input_sample_tampering'] = input_sample_tampering
            if type(tor_enabled_analysis) is bool:
                data['tor_enabled_analysis'] = tor_enabled_analysis
            if type(offline_analysis) is bool:
                data['offline_analysis'] = offline_analysis
            if email is not None and type(email) is str:
                data['email'] = email
            if properties is not None and type(properties) is str:
                data['properties'] = properties
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if custom_date_time is not None and type(custom_date_time) is str:
                # validate time format
                data['custom_date_time'] = custom_date_time
            if custom_cmd_line is not None and type(custom_cmd_line) is str:
                data['custom_cmd_line'] = custom_cmd_line
            if custom_run_time is not None and type(custom_run_time) is int:
                data['custom_run_time'] = custom_run_time
            if client is not None and type(client) is str:
                data['client'] = client
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name
            if priority is not None and type(priority) is int and priority in range(0, 100+1):
                data['priority'] = priority
            if document_password is not None and type(document_password) is str:
                data['document_password'] = document_password
            if environment_variable is not None and type(environment_variable) is str:
                data['environment_variable'] = environment_variable

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def url_to_file(self, url: str, environment_id: str, no_share_third_party: bool = True, allow_community_access: bool = True, no_hash_lookup: bool = False, action_script: str = None, hybrid_analysis: bool = True, experimental_anti_evasion: bool = False, script_logging: bool = False, input_sample_tampering: bool = False, tor_enabled_analysis: bool = False, offline_analysis: bool = False, email: str = None, properties: str = None, comment: str = None, custom_date_time: str = None, custom_cmd_line: str = None, custom_run_time: int = None, client: str = None, submit_name: str = None, priority: int = 0, document_password: str = None, environment_variable: str = None) -> str:
            # POST
            request_url = self.baseurl + '/url-to-file'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if url is not None and type(url) is str:
                data['url'] = url
            if environment_id is not None and type(environment_id) is int:
                data['environment_id'] = environment_id
            
            if url is None or environment_id is None:
                raise Exception('Missing url or environment_id!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if type(no_hash_lookup) is bool:
                data['no_hash_lookup'] = no_hash_lookup
            if action_script is not None and type(action_script) is str:
                data['action_script'] = action_script
            if type(hybrid_analysis) is bool:
                data['hybrid_analysis'] = hybrid_analysis
            if type(experimental_anti_evasion) is bool:
                data['experimental_anti_evasion'] = experimental_anti_evasion
            if type(script_logging) is bool:
                data['script_logging'] = script_logging
            if type(input_sample_tampering) is bool:
                data['input_sample_tampering'] = input_sample_tampering
            if type(tor_enabled_analysis) is bool:
                data['tor_enabled_analysis'] = tor_enabled_analysis
            if type(offline_analysis) is bool:
                data['offline_analysis'] = offline_analysis
            if email is not None and type(email) is str:
                data['email'] = email
            if properties is not None and type(properties) is str:
                data['properties'] = properties
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if custom_date_time is not None and type(custom_date_time) is str:
                # validate time format
                data['custom_date_time'] = custom_date_time
            if custom_cmd_line is not None and type(custom_cmd_line) is str:
                data['custom_cmd_line'] = custom_cmd_line
            if custom_run_time is not None and type(custom_run_time) is int:
                data['custom_run_time'] = custom_run_time
            if client is not None and type(client) is str:
                data['client'] = client
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name
            if priority is not None and type(priority) is int and priority in range(0, 100+1):
                data['priority'] = priority
            if document_password is not None and type(document_password) is str:
                data['document_password'] = document_password
            if environment_variable is not None and type(environment_variable) is str:
                data['environment_variable'] = environment_variable

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def url_for_analysis(self, url: str, environment_id: str, no_share_third_party: bool = True, allow_community_access: bool = True, no_hash_lookup: bool = False, action_script: str = None, hybrid_analysis: bool = True, experimental_anti_evasion: bool = False, script_logging: bool = False, input_sample_tampering: bool = False, tor_enabled_analysis: bool = False, offline_analysis: bool = False, email: str = None, properties: str = None, comment: str = None, custom_date_time: str = None, custom_cmd_line: str = None, custom_run_time: int = None, client: str = None, submit_name: str = None, priority: int = 0, document_password: str = None, environment_variable: str = None) -> str:
            # POST
            request_url = self.baseurl + '/url-for-analysis'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if url is not None and type(url) is str:
                data['url'] = url
            if environment_id is not None and type(environment_id) is str:
                data['environment_id'] = environment_id
            
            if url is None or environment_id is None:
                raise Exception('Missing url or environment_id!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            if type(allow_community_access) is bool:
                data['allow_community_access'] = allow_community_access
            if type(no_hash_lookup) is bool:
                data['no_hash_lookup'] = no_hash_lookup
            if action_script is not None and type(action_script) is str:
                data['action_script'] = action_script
            if type(hybrid_analysis) is bool:
                data['hybrid_analysis'] = hybrid_analysis
            if type(experimental_anti_evasion) is bool:
                data['experimental_anti_evasion'] = experimental_anti_evasion
            if type(script_logging) is bool:
                data['script_logging'] = script_logging
            if type(input_sample_tampering) is bool:
                data['input_sample_tampering'] = input_sample_tampering
            if type(tor_enabled_analysis) is bool:
                data['tor_enabled_analysis'] = tor_enabled_analysis
            if type(offline_analysis) is bool:
                data['offline_analysis'] = offline_analysis
            if email is not None and type(email) is str:
                data['email'] = email
            if properties is not None and type(properties) is str:
                data['properties'] = properties
            if comment is not None and type(comment) is str:
                data['comment'] = comment
            if custom_date_time is not None and type(custom_date_time) is str:
                # validate time format
                data['custom_date_time'] = custom_date_time
            if custom_cmd_line is not None and type(custom_cmd_line) is str:
                data['custom_cmd_line'] = custom_cmd_line
            if custom_run_time is not None and type(custom_run_time) is int:
                data['custom_run_time'] = custom_run_time
            if client is not None and type(client) is str:
                data['client'] = client
            if submit_name is not None and type(submit_name) is str:
                data['submit_name'] = submit_name
            if priority is not None and type(priority) is int and priority in range(0, 100+1):
                data['priority'] = priority
            if document_password is not None and type(document_password) is str:
                data['document_password'] = document_password
            if environment_variable is not None and type(environment_variable) is str:
                data['environment_variable'] = environment_variable

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def hash_for_url(self, url: str):
            # POST
            request_url = self.baseurl + '/hash-for-url'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}

            if url is not None and type(url) is str:
                data['url'] = url
            else:
                raise Exception('Missing or invalid url!')

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def dropped_file(self, id: str, file_hash: str, no_share_third_party: bool = True) -> str:
            # POST
            request_url = self.baseurl + '/dropped-file'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {}
            if id is not None and type(id) is str:
                data['id'] = id
            if file_hash is not None and type(file_hash) is str:
                data['file_hash'] = file_hash
            
            if id is None or file_hash is None:
                raise Exception('Missing id or file_hash!')

            if type(no_share_third_party) is bool:
                data['no_share_third_party'] = no_share_third_party
            
            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)
            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class SandboxReport:
        """ A wrapper class containing all Sandbox report-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/report'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/report'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/{id}/state", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/summary", "method": "GET"},
                {"url": endpoints['base'] + "/summary", "method": "POST"},
                {"url": endpoints['base'] + "/{id}/file/{type}", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/screenshots", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/dropped-file-raw/{hash}", "method": "GET"},
                {"url": endpoints['base'] + "/{id}/dropped-files", "method": "GET"}
            ]
            return endpoints

        def id_state(self, id: str):
            # GET
            request_url = self.baseurl + '/{}/state'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_summary(self, id: str):
            # GET
            request_url = self.baseurl + '/{}/summary'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_summary_multiple(self, ids: list):
            if ids is not None and type(ids) is not list:
                raise Exception()

            # POST
            request_url = self.baseurl + '/{}/summary'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            data = {'hashes': ids}

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_file_type(self, id: str, type: str):
            # GET
            request_url = self.baseurl + '/{}/summary/{}'.format(id, type)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_screenshots(self, id: str):
            # GET
            request_url = self.baseurl + '/{}/screenshots'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_dropped_file_raw(self, id: str, hash: str):
            # GET
            request_url = self.baseurl + '/{}/dropped-file-raw/{}'.format(id, hash)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def id_dropped_files(self, id: str):
            # GET
            request_url = self.baseurl + '/{}/dropped-files'.format(id)
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class System:
        """ A wrapper class containing all system-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/system'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/system'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/version", "method": "GET"},
                {"url": endpoints['base'] + "/environments", "method": "GET"},
                {"url": endpoints['base'] + "/stats", "method": "GET"},
                {"url": endpoints['base'] + "/state", "method": "GET"},
                {"url": endpoints['base'] + "/configuration", "method": "GET"},
                {"url": endpoints['base'] + "/backend", "method": "GET"},
                {"url": endpoints['base'] + "/queue-size", "method": "GET"},
                {"url": endpoints['base'] + "/in-progress", "method": "GET"},
                {"url": endpoints['base'] + "/total-submissions", "method": "GET"},
                {"url": endpoints['base'] + "/heartbeat", "method": "GET"}
            ]
            return endpoints

        def version(self):
            # GET
            request_url = self.baseurl + '/version'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def environments(self):
            # GET
            request_url = self.baseurl + '/environments'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def stats(self):
            # GET
            request_url = self.baseurl + '/stats'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def state(self):
            # GET
            request_url = self.baseurl + '/state'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def configuration(self):
            # GET
            request_url = self.baseurl + '/configuration'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def backend(self):
            # GET
            request_url = self.baseurl + '/backend'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def queue_size(self):
            # GET
            request_url = self.baseurl + '/queue-size'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def in_progress(self):
            # GET
            request_url = self.baseurl + '/in-progress'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def total_submissions(self):
            # GET
            request_url = self.baseurl + '/total-submissions'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

        def heartbeat(self):
            # GET
            request_url = self.baseurl + '/heartbeat'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class Key:
        """ A wrapper class containing all key-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/key'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/key'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/current", "method": "GET"}
            ]
            return endpoints

        def current(self):
            # GET
            request_url = self.baseurl + '/current'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class Feed:
        """ A wrapper class containing all feed-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/feed'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/feed'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/latest", "method": "GET"}
            ]
            return endpoints

        def latest(self):
            # GET
            request_url = self.baseurl + '/latest'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            try:
                response = requests.get(request_url, headers=headers)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)

    class AbuseReports:
        """ A wrapper class containing all abuse-report-related API calls for HybridAnalysis """

        def __init__(self, api, level, baseurl, ua):
            self.apikey = api
            self.level = level
            self.ua = ua
            self.baseurl = baseurl + '/abuse-reports'

        def __repr__(self):
                return str(self.getEndpoints())

        def getEndpoints(self) -> dict:
            endpoints = {}
            endpoints['base'] = '/abuse-reports'
            endpoints['endpoints'] = [
                {"url": endpoints['base'] + "/new", "method": "POST"}
            ]
            return endpoints

        def new(self, hash: str, reason: str):
            # POST
            request_url = self.baseurl + '/new'
            headers = {
                'api-key': self.apikey,
                'user-agent': self.ua,
                'accept': 'application/json'
            }

            if hash is None or reason is None:
                raise Exception('Invalid Usage! Missing either sha256 hash or reason!')

            data = {
                'sha256': hash,
                'reason': reason
            }

            try:
                response = requests.post(request_url, headers=headers, data=data)
            except requests.exceptions.ConnectionError:
                raise ConnectionError(request_url)

            if handleAPIResponse(response.status_code):
                return loads(response.text)
